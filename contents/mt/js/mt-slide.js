// Generated by CoffeeScript 1.3.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  define(['zepto', 'mt-base', 'text!../templates/mt-slide.html', 'css!../css/mt-slide.css', 'css!../css/app.css'], function($, MTBase, template) {
    var MTSlide, Slider;
    Slider = (function() {
      var autoSlideTimeouts, defaults, grabInCursor, grabOutCursor, isEventCleared, isTouch, isWebkit, lastTouch, onChangeEventLastFired, panelOffset, slideTimeouts, sliderMin, _helpers;

      Slider.name = 'Slider';

      panelOffset = 52;

      isTouch = __indexOf.call(window, 'ontouchstart') >= 0;

      sliderMin = 0;

      isWebkit = false;

      onChangeEventLastFired = [];

      grabOutCursor = null;

      grabInCursor = null;

      isEventCleared = [];

      autoSlideTimeouts = [];

      slideTimeouts = [];

      lastTouch = null;

      _helpers = {
        getSliderOffset: function(node, xy) {
          var sliderOffset, webkitTransformArray;
          sliderOffset = 0;
          xy = xy === 'x' ? 4 : 5;
          if (isTouch || isWebkit) {
            webkitTransformArray = window.getComputedStyle(node).webkitTransform.split(',');
            sliderOffset = parseInt(webkitTransformArray[xy], 10);
          } else {
            sliderOffset = parseInt(node.style.left);
          }
          return sliderOffset;
        },
        calcActiveOffset: function(settings, offset, snapDirection, childrenOffsets, sliderMax, stageWidth, activeChildOffset) {
          var arrayOfOffsets, childOffset, closestChildOffset, distance, i, isFirst, newChildOffset, newDistance, _i, _j, _k, _len, _len1, _len2, _offset;
          isFirst = false;
          arrayOfOffsets = [];
          newChildOffset = null;
          for (i = _i = 0, _len = childrenOffsets.length; _i < _len; i = ++_i) {
            childOffset = childrenOffsets[i];
            if ((offset - stageWidth + panelOffset < childOffset && childOffset <= offset + panelOffset)) {
              if (!isFirst && childOffset !== offset) {
                arrayOfOffsets[arrayOfOffsets.lenth] = childrenOffsets[i - 1];
              }
              arrayOfOffsets[arrayOfOffsets.length] = childOffset;
              isFirst = true;
            }
          }
          if (arrayOfOffsets.length === 0) {
            arrayOfOffsets[0] = childrenOffsets[childrenOffsets.length - 1];
          }
          distance = stageWidth;
          closestChildOffset = 0;
          for (i = _j = 0, _len1 = arrayOfOffsets.length; _j < _len1; i = ++_j) {
            _offset = arrayOfOffsets[i];
            newDistance = Math.abs(offset - _offset);
            if (newDistance < distance) {
              closestChildOffset = _offset;
              distance = newDistance;
            }
          }
          for (i = _k = 0, _len2 = childrenOffsets.length; _k < _len2; i = ++_k) {
            childOffset = childrenOffsets[i];
            if (closestChildOffset === childOffset) {
              newChildOffset = i;
            }
          }
          if (snapDirection < 0) {
            newChildOffset = activeChildOffset + 1;
            if (newChildOffset >= childrenOffsets.length) {
              newChildOffset = childrenOffsets.length - 1;
            }
          } else if (snapDirection > 0) {
            newChildOffset = activeChildOffset - 1;
            if (newChildOffset < 0) {
              newChildOffset = 0;
            }
          }
          return newChildOffset;
        },
        args: function(settings, node, activeSlideNode, newChildOffset) {
          this.settings = settings;
          this.sliderObject = node;
          this.currentSlideObject = activeSlideNode;
          return this.currentSlideNumber = newChildOffset;
        },
        getOuter: function(el, wh) {
          var borderWidth, style;
          style = window.getComputedStyle(el);
          if (wh === 'w') {
            borderWidth = parseInt(style.borderLeftWidth, 10) + parseInt(style.borderRightWidth, 10);
            return el.clientWidth + parseInt(style.marginLeft, 10) + parseInt(style.marginLeft, 10) + borderWidth;
          } else {
            return el.clientHeight + parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
          }
        },
        getAnimationSteps: function(settings, xScrollDistance, nodeOffset, sliderMax, sliderMin, childrenOffsets) {
          var activeChildOffset, offsets;
          offsets = new Array();
          if ((xScrollDistance <= 1) && (xScrollDistance >= 0)) {
            xScrollDistance = -2;
          } else if ((xScrollDistance >= -1) && (xScrollDistance <= 0)) {
            xScrollDistance = 2;
          }
          while ((xScrollDistance > 1) || (xScrollDistance < -1)) {
            xScrollDistance = xScrollDistance * settings.frictionCoefficient;
            nodeOffset = nodeOffset + xScrollDistance;
            offsets[offsets.length] = nodeOffset;
          }
          activeChildOffset = 0;
          return offsets;
        },
        slowScrollHorizontalInterval: function(node, newOffset, sliderMax, scrollbarClass, scrollbarWidth, stageWidth, scrollMargin, scrollBorder, activeChildOffset, childrenOffsets, infiniteSliderWidth, infiniteSliderOffset, numberOfSlides, settings) {
          var newChildOffset;
          newChildOffset = _helpers.calcActiveOffset(settings, newOffset, 0, childrenOffsets, sliderMax, stageWidth, undefined);
          newOffset = Math.floor(newOffset);
          return _helpers.setSliderOffset(node, newOffset);
        },
        slowScrollHorizontalIntervalTimer: function(scrollIntervalTime, node, step, sliderMax, scrollbarClass, scrollbarWidth, stageWidth, scrollMargin, scrollBorder, slide, childrenOffsets, infiniteSliderWidth, infiniteSliderOffset, numberOfSlides, settings) {
          var scrollTimeout;
          scrollTimeout = setTimeout(function() {
            return _helpers.slowScrollHorizontalInterval(node, step, sliderMax, scrollbarClass, scrollbarWidth, stageWidth, scrollMargin, scrollBorder, slide, childrenOffsets, infiniteSliderWidth, infiniteSliderOffset, numberOfSlides, settings);
          }, scrollIntervalTime);
          return scrollTimeout;
        },
        onSlideCompleteTimer: function(scrollIntervalTime, settings, node, slideNode, slide, scrollbarNumber) {
          var scrollTimeout;
          scrollTimeout = setTimeout(function() {
            return console.log("done");
          }, scrollIntervalTime);
          return scrollTimeout;
        },
        slowScrollHorizontal: function(node, scrollTimeouts, sliderMax, scrollbarClass, xScrollDistance, yScrollDistance, scrollbarWidth, stageWidth, scrollMargin, scrollBorder, activeChildOffset, childrenOffsets, sliderNumber, infiniteSliderOffset, infiniteSliderWidth, numberOfSlides, settings) {
          var $newChild, changeSlideFired, distanceOffsetArray, elasticFrictionCoefficient, frictionCoefficient, j, maxSlideVelocity, newChildOffset, nodeOffset, scrollIntervalTime, snapDirection, snapFrictionCoefficient, snapToChildren, testNodeOffsets, _isLastOffsetBigger, _isLastOffsetSmaller, _isLeftward, _isRightward;
          distanceOffsetArray = [];
          nodeOffset = _helpers.getSliderOffset(node, "x");
          snapDirection = 0;
          maxSlideVelocity = 25 / 1024 * stageWidth;
          changeSlideFired = false;
          scrollIntervalTime = 10;
          frictionCoefficient = settings.frictionCoefficient, elasticFrictionCoefficient = settings.elasticFrictionCoefficient, snapFrictionCoefficient = settings.snapFrictionCoefficient, snapToChildren = settings.snapToChildren;
          if (snapToChildren) {
            if (xScrollDistance > 5) {
              snapDirection = 1;
            } else if (xScrollDistance < -5) {
              snapDirection = -1;
            }
          }
          if (xScrollDistance < (maxSlideVelocity * -1)) {
            xScrollDistance = maxSlideVelocity * -1;
          } else if (xScrollDistance > maxSlideVelocity) {
            xScrollDistance = maxSlideVelocity;
          }
          testNodeOffsets = _helpers.getAnimationSteps(settings, xScrollDistance, nodeOffset, sliderMax, sliderMin, childrenOffsets);
          newChildOffset = _helpers.calcActiveOffset(settings, nodeOffset, snapDirection, childrenOffsets, sliderMin, stageWidth, activeChildOffset);
          if (settings.infiniteSlider) {
            if (childrenOffsets[newChildOffset] > (childrenOffsets[numberOfSlides + 1] + stageWidth)) {
              newChildOffset = newChildOffset + numberOfSlides;
            }
            if (childrenOffsets[newChildOffset] < (childrenOffsets[numberOfSlides * 2 - 1] - stageWidth)) {
              newChildOffset = newChildOffset - numberOfSlides;
            }
          }
          _isLastOffsetSmaller = testNodeOffsets[testNodeOffsets.length - 1] < childrenOffsets[newChildOffset];
          _isLeftward = snapDirection < 0;
          _isLastOffsetBigger = testNodeOffsets[testNodeOffsets.length - 1] > childrenOffsets[newChildOffset];
          _isRightward = snapDirection > 0;
          if ((_isLastOffsetSmaller && _isLeftward) || (_isLastOffsetBigger && _isRightward) || (!snapToChildren)) {
            while ((xScrollDistance > 1) || (xScrollDistance < -1)) {
              xScrollDistance = xScrollDistance * frictionCoefficient;
              nodeOffset = nodeOffset + xScrollDistance;
              distanceOffsetArray.push(nodeOffset);
            }
          }
          if (snapToChildren || (nodeOffset > sliderMin) || (nodeOffset < (sliderMax * -1))) {
            while ((nodeOffset < (childrenOffsets[newChildOffset] - 0.5)) || (nodeOffset > (childrenOffsets[newChildOffset] + 0.5))) {
              nodeOffset = ((nodeOffset - childrenOffsets[newChildOffset]) * snapFrictionCoefficient) + childrenOffsets[newChildOffset];
              distanceOffsetArray[distanceOffsetArray.length] = nodeOffset;
            }
            distanceOffsetArray[distanceOffsetArray.length] = childrenOffsets[newChildOffset];
          }
          j = distanceOffsetArray.length % 2 === 0 ? 1 : 0;
          while (j < distanceOffsetArray.length) {
            scrollTimeouts[scrollTimeouts.length] = _helpers.slowScrollHorizontalIntervalTimer(scrollIntervalTime * j, node, distanceOffsetArray[j], sliderMax, scrollbarClass, scrollbarWidth, stageWidth, scrollMargin, scrollBorder, newChildOffset, childrenOffsets, infiniteSliderWidth, infiniteSliderOffset, numberOfSlides, settings);
            j = j + 2;
          }
          $newChild = $(node).children().removeClass('on').eq(newChildOffset).addClass('on');
          scrollTimeouts[scrollTimeouts.length] = _helpers.onSlideCompleteTimer(scrollIntervalTime * (j + 1), settings, node, $newChild, newChildOffset % infiniteSliderOffset, sliderNumber);
          slideTimeouts[sliderNumber] = scrollTimeouts;
          return newChildOffset;
        },
        setSliderOffset: function(node, sliderOffset) {
          if (isTouch || isWebkit) {
            return node.style.webkitTransform = "translateX(" + sliderOffset + "px)";
          } else {
            return node.style.left = sliderOffset + "px";
          }
        },
        setBrowserInfo: function() {
          var isGecko, isIe, isIe7, isIe8, isIe9;
          if (navigator.userAgent.match("WebKit") != null) {
            isWebkit = true;
            grabOutCursor = "-webkit-grab";
            return grabInCursor = "-webkit-grabbing";
          } else if (navigator.userAgent.match("Gecko") != null) {
            isGecko = true;
            grabOutCursor = "move";
            return grabInCursor = "-moz-grabbing";
          } else if (navigator.userAgent.match("MSIE 7") != null) {
            isIe7 = true;
            return isIe = true;
          } else if (navigator.userAgent.match("MSIE 8") != null) {
            isIe8 = true;
            return isIe = true;
          } else if (navigator.userAgent.match("MSIE 9") != null) {
            isIe9 = true;
            return isIe = true;
          }
        }
      };

      defaults = {
        'elasticPullResistance': 0.6,
        'frictionCoefficient': 0.92,
        'elasticFrictionCoefficient': 0.6,
        'snapFrictionCoefficient': 0.92,
        'snapToChildren': true,
        'startAtSlide': 1,
        'desktopClickDrag': true,
        'infiniteSlider': true,
        'onSliderLoaded': function() {},
        'onSlideChange': function() {},
        'onSlideComplete': function() {}
      };

      function Slider(stageNode, settings) {
        this.stageNode = stageNode;
        if (settings == null) {
          settings = {};
        }
        this.init = __bind(this.init, this);

        this.settings = $.extend(defaults, settings);
        this.scrollerNode = this.stageNode.children[0];
        _helpers.setBrowserInfo();
        this.scrollTimeouts = [];
        this.childrenOffsets = [];
        this.sliderMax = 0;
        this.stageWidth = _helpers.getOuter(this.stageNode, 'w');
        this.numberOfSlides = $(this.scrollerNode).children().size();
        this.activeChildOffset = this.settings.startAtSlide - 1;
        if (this.settings.infiniteSlider) {
          $(this.scrollerNode).children().clone().prependTo(this.scrollerNode).clone().appendTo(this.scrollerNode);
          this.infiniteSliderOffset = this.numberOfSlides;
        }
        this.slideNodes = $(this.scrollerNode).children();
        if (!this.init()) {
          return true;
        }
        if (this.settings.infiniteSlider) {
          this.activeChildOffset = this.activeChildOffset + this.infiniteSliderOffset;
          this.slideNodes.eq(this.activeChildOffset).addClass('on');
          _helpers.setSliderOffset(this.scrollerNode, this.childrenOffsets[this.activeChildOffset]);
        }
        this.attachEvents();
      }

      Slider.prototype.init = function() {
        var i, offset, _i, _len, _ref,
          _this = this;
        this.stageNode.style.width = '';
        $(this.slideNodes).css('width', '');
        this.sliderMax = 0;
        this.childrenOffsets = [];
        this.containerWidth = this.stageNode.parentNode.clientWidth;
        this.containerHeight = this.stageNode.parentNode.clientHeight;
        this.stageWidth = _helpers.getOuter(this.stageNode, 'w');
        this.stageHeight = _helpers.getOuter(this.stageNode, 'h');
        $(this.stageNode).css({
          position: 'relative',
          top: '0',
          left: '0',
          overflow: 'hidden',
          zIndex: 1,
          width: this.stageWidth,
          height: this.stageHeight
        });
        $(this.scrollerNode).children().each(function(i, item) {
          item.style.float = 'left';
          _this.childrenOffsets[i] = _this.sliderMax * -1 + panelOffset;
          return _this.sliderMax = _this.sliderMax + _helpers.getOuter(item, 'w');
        });
        _ref = this.childrenOffsets;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          offset = _ref[i];
          if (offset <= (this.sliderMax - this.stageWidth) * -1) {
            break;
          }
          this.lastChildOffset = i;
        }
        this.childrenOffsets.splice(this.lastChildOffset + 1, this.childrenOffsets.length);
        this.childrenOffsets[this.childrenOffsets.length] = (this.sliderMax - this.stageWidth) * -1;
        this.sliderMax = this.sliderMax - this.stageWidth;
        $(this.scrollerNode).css({
          webkitPerspective: 1000,
          webkitBackfaceVisibility: 'hidden',
          position: 'relative',
          cursor: grabOutCursor,
          width: this.sliderMax + this.stageWidth + 'px',
          overflow: 'hidden'
        });
        _helpers.setSliderOffset(this.scrollerNode, this.childrenOffsets[this.activeChildOffset]);
        if (this.sliderMax <= 0) {
          this.scrollerNode.style.cursor = 'default';
          return false;
        }
        if (this.settings.infiniteSlider) {
          this.infiniteSliderWidth = (this.sliderMax + this.stageWidth) / 3;
        }
        return true;
      };

      Slider.prototype.disableSelection = function() {
        if (!isTouch) {
          if (window.getSelection != null) {
            if ((typeof window.getSelection === "function" ? window.getSelection().empty : void 0) != null) {
              return typeof window.getSelection === "function" ? window.getSelection().empty() : void 0;
            } else if ((typeof window.getSelection === "function" ? window.getSelection().removeAllRanges : void 0) != null) {
              return window.getSelection().removeAllRanges();
            }
          } else if (document.selection) {
            return document.selection.empty();
          }
        }
      };

      Slider.prototype.attachEvents = function() {
        var eventObject,
          _this = this;
        if (isTouch || this.settings.desktopClickDrag) {
          $(this.scrollerNode).on('touchstart mousedown', 'li', function(e) {
            var eventX, eventY, scrollPosition, timeout, _i, _len, _ref;
            _this.disableSelection();
            if (isTouch) {
              eventX = e.touches[0].pageX;
              eventY = e.touches[0].pageY;
            } else {
              eventX = e.pageX;
              eventY = e.pageY;
              _this.isMouseDown = true;
              _this.currentSlider = _this.scrollerNode;
              _this.scrollerNode.style.cursor = grabInCursor;
            }
            _this.xCurrentScrollRate = [0, 0];
            _this.yCurrentScrollRate = [0, 0];
            _this.xScrollDistance = 0;
            _this.xScrollStarted = false;
            _ref = _this.scrollTimeouts;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              timeout = _ref[_i];
              clearTimeout(timeout);
            }
            scrollPosition = _helpers.getSliderOffset(_this.scrollerNode, 'x');
            _this.activeChildOffset = _helpers.calcActiveOffset(_this.settings, scrollPosition, 0, _this.childrenOffsets, _this.sliderMax, _this.stageWidth, void 0);
            _this.intermediateChildOffset = _this.activeChildOffset;
            if (_this.settings.infiniteSlider) {
              if (_this.activeSlideNode % _this.numberOfSlides === 0) {
                $(_this.scrollerNode).children(":nth-child(" + _this.numberOfSlides + "n+1)").html($(_this.scrollerNode).children(":eq(" + _this.activeChildOffset + ")").html());
              }
            }
            if (scrollPosition > sliderMin) {
              scrollPosition = sliderMin;
              _helpers.setSliderOffset(_this.scrollerNode, scrollPosition);
            } else if (scrollPosition < (_this.sliderMax * -1)) {
              scrollPosition = _this.sliderMax * -1;
              _helpers.setSliderOffset(_this.scrollerNode, scrollPosition);
            }
            _this.xScrollStartPosition = (_helpers.getSliderOffset(_this.scrollerNode, 'x') - eventX) * -1;
            _this.yScrollStartPosition = (_helpers.getSliderOffset(_this.scrollerNode, 'y') - eventY) * -1;
            _this.xCurrentScrollRate[1] = eventX;
            return _this.yCurrentScrollRate[1] = eventY;
          });
          $(this.scrollerNode).on('touchmove mousemove', function(e) {
            var edgeDegradation, eventX, eventY, scrollPosition;
            if (!isTouch) {
              _this.disableSelection();
            }
            if (isTouch) {
              eventX = e.touches[0].pageX;
              eventY = e.touches[0].pageY;
            } else {
              eventX = e.pageX;
              eventY = e.pageY;
              if (!_this.isMouseDown) {
                return false;
              }
            }
            if (_this.settings.infiniteSlider) {
              if (_helpers.getSliderOffset(_this.scrollerNode, 'x') > _this.childrenOffsets[_this.numberOfSlides + 1] + _this.stageWidth) {
                _this.xScrollStartPosition = _this.xScrollStartPosition + _this.infiniteSliderWidth;
              }
              if (_helpers.getSliderOffset(_this.scrollerNode, 'x') < _this.childrenOffsets[_this.numberOfSlides * 2 - 1] - _this.stageWidth) {
                _this.xScrollStartPosition = _this.xScrollStartPosition - _this.infiniteSliderWidth;
              }
            }
            _this.xCurrentScrollRate[0] = _this.xCurrentScrollRate[1];
            _this.xCurrentScrollRate[1] = eventX;
            _this.xScrollDistance = (_this.xCurrentScrollRate[1] - _this.xCurrentScrollRate[0]) / 2;
            _this.yCurrentScrollRate[0] = _this.yCurrentScrollRate[1];
            _this.yCurrentScrollRate[1] = eventY;
            _this.yScrollDistance = (_this.yCurrentScrollRate[1] - _this.yCurrentScrollRate[0]) / 2;
            if ((_this.xScrollDistance > 5 || _this.xScrollDistance < -5) && isTouch) {
              e.preventDefault();
              _this.xScrollStarted = true;
            } else if (!isTouch) {
              _this.xScrollStarted = true;
            }
            if (_this.xScrollStarted) {
              scrollPosition = _helpers.getSliderOffset(_this.scrollerNode, 'x');
              if (isTouch) {
                if (_this.currentTouches !== e.touches.length) {
                  _this.xScrollStartPosition = (scrollPosition * -1) + eventX;
                }
                _this.currentTouches = e.touches.length;
              }
              edgeDegradation = 0;
              _this.elasticPullResistance = _this.settings.elasticPullResistance;
              if (scrollPosition > sliderMin) {
                edgeDegradation = (_this.xScrollStartPosition - eventX) * _this.elasticPullResistance;
              }
              if (scrollPosition < _this.sliderMax * -1) {
                edgeDegradation = (_this.sliderMax + ((_this.xScrollStartPosition - eventX) * -1)) * _this.elasticPullResistance * -1;
              }
              _helpers.setSliderOffset(_this.scrollerNode, (_this.xScrollStartPosition - eventX - edgeDegradation) * -1);
              if (isTouch) {
                lastTouch = e.touches[0].pageX;
              }
            }
            _this.newChildOffset = _helpers.calcActiveOffset(_this.settings, (_this.xScrollStartPosition - eventX - edgeDegradation) * -1, 0, _this.childrenOffsets, _this.sliderMax, _this.stageWidth, void 0);
            if (_this.newChildOffset !== _this.intermediateChildOffset) {
              _this.intermediateChildOffset = _this.newChildOffset;
              return _this.settings.onSlideChange(new _helpers.args(_this.settings, _this.slideNode, $(_this.slideNode).children().eq(_this.newChildOffset), _this.newChildOffset % _this.infiniteSliderOffset));
            }
          });
          $(this.scrollerNode).on('touchend', function(e) {
            var j, _results;
            if (event.touches.length === 0) {
              return _this.activeChildOffset = _helpers.slowScrollHorizontal(_this.scrollerNode, _this.scrollTimeouts, _this.sliderMax, _this.scrollbarClass, _this.xScrollDistance, _this.yScrollDistance, _this.scrollbarWidth, _this.stageWidth, _this.scrollMargin, _this.scrollBorder, _this.activeChildOffset, _this.childrenOffsets, _this.sliderNumber, _this.infiniteSliderOffset, _this.infiniteSliderWidth, _this.numberOfSlides, _this.settings);
            } else {
              j = 0;
              _results = [];
              while (j < event.touches.length) {
                if (event.touches[j].pageX === lastTouch) {
                  _this.activeChildOffset = _helpers.slowScrollHorizontal(_this.scrollerNode, _this.scrollTimeouts, _this.sliderMax, _this.scrollbarClass, _this.xScrollDistance, _this.yScrollDistance, _this.scrollbarWidth, _this.stageWidth, _this.scrollMargin, _this.scrollBorder, _this.activeChildOffset, _this.childrenOffsets, _this.sliderNumber, _this.infiniteSliderOffset, _this.infiniteSliderWidth, _this.numberOfSlides, _this.settings);
                }
                _results.push(j++);
              }
              return _results;
            }
          });
          if (!isTouch) {
            eventObject = $(window);
            return $(eventObject).on('mouseup', function(e) {
              if (!_this.isMouseDown) {
                return true;
              }
              if (!isEventCleared[_this.sliderNumber]) {
                $(_this.scrollerNode).css({
                  cursor: grabOutCursor
                });
                _this.isMouseDown = false;
                if ((!(_this.currentSlider != null)) || _this.xCurrentScrollRate[0] === 0) {
                  return false;
                }
                return _this.activeChildOffset = _helpers.slowScrollHorizontal(_this.scrollerNode, _this.scrollTimeouts, _this.sliderMax, _this.scrollbarClass, _this.xScrollDistance, _this.yScrollDistance, _this.scrollbarWidth, _this.stageWidth, _this.scrollMargin, _this.scrollBorder, _this.activeChildOffset, _this.childrenOffsets, _this.sliderNumber, _this.infiniteSliderOffset, _this.infiniteSliderWidth, _this.numberOfSlides, _this.settings);
              }
            });
          }
        }
      };

      return Slider;

    })();
    return MTSlide = (function(_super) {

      __extends(MTSlide, _super);

      MTSlide.name = 'MTSlide';

      function MTSlide() {
        return MTSlide.__super__.constructor.apply(this, arguments);
      }

      MTSlide.prototype.init = function() {
        return this.slider = new Slider(this.el.get(0));
      };

      MTSlide.prototype.setupDOM = function() {
        this.el.append(template);
        return MTSlide.__super__.setupDOM.apply(this, arguments);
      };

      return MTSlide;

    })(MTBase);
  });

}).call(this);
